// Pentagonal numbers are generated by the formula, P(n)=n(3n−1)/2.
// The first ten pentagonal numbers are:
//      1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...
// It can be seen that P(4) + P(7) = 22 + 70 = 92 = P(8). However, their difference, 70 − 22 = 48, is not pentagonal.
// Find the pair of pentagonal numbers, P(j) and P(k),
// for which their sum and difference are pentagonal and D = |P(k) − P(j)| is minimised; what is the value of D?


#include <iostream>
#include <set>
#include <unordered_set>
#include <vector>


std::vector<uint64_t> get_pentagonal_numbers(uint64_t n) {
    std::vector<uint64_t> ret{ 1 };

    //p(n) = n(3n-1)/2 = 3/2 n^2 - n/2
    //p(n+1) = (n+1)(3n+2)/2 = 3/2 n^2 + 5/2 n + 1
    //p(n+1) - p(n) = 3 n + 1

    for (uint64_t i = 1; i < n; ++i)
        ret.push_back(ret.back() + 3 * i + 1);

    return ret;
}


std::set<std::pair<uint64_t, uint64_t>> get_special_pentagonals(int32_t maxN) {
    std::set<std::pair<uint64_t, uint64_t>> ret;

    std::vector<uint64_t> pents = get_pentagonal_numbers(maxN);
    std::unordered_set<uint64_t> pent_set(pents.begin(), pents.end());

    // Iterate over all pentagonal numbers
    for (auto iter1 = pents.begin(); iter1 != pents.end(); ++iter1) {
        // Iterate over all pentagonal numbers greater than *iter1, so *iter2 - *iter1 > 0
        auto iter2 = iter1;
        for (++iter2; iter2 != pents.end(); ++iter2) {
            if (pent_set.find(*iter2 - *iter1) == pent_set.end())
                continue;
            if (pent_set.find(*iter2 + *iter1) == pent_set.end())
                continue;
            ret.insert(std::make_pair(*iter1, *iter2));
        }
    }

    return ret;
}


int main()
{
    std::cout << "Hello World!\n";

    auto numbers = get_pentagonal_numbers(10);
    for (const auto& n : numbers) {
        std::cout << n << std::endl;
    }

    auto pairs = get_special_pentagonals(100000);
    for (const auto& p : pairs) {
        std::cout << p.second << " - " << p.first << " = " << p.second - p.first << std::endl;
    }
}
