// If we are presented with the first k terms of a sequence it is impossible to say with certainty the
// value of the next term, as there are infinitely many polynomial functions that can model the sequence.
//
// As an example, let us consider the sequence of cube numbers.  This is defined by the generating function,
//      un = n^3: 1, 8, 27, 64, 125, 216, ...
//
// Suppose we were only given the first two terms of this sequence.  Working on the principle that
// "simple is best" we should assume a linear relationship and predict the next term to be 15
// (common difference 7).Even if we were presented with the first three terms, by the same
// principle of simplicity, a quadratic relationship should be assumed.
//
// We shall define OP(k, n) to be the nth term of the optimum polynomial generating function for
// the first k terms of a sequence.It should be clear that OP(k, n) will accurately generate the
// terms of the sequence for n <= k, and potentially the first incorrect term(FIT) will be
// OP(k, k + 1); in which case we shall call it a bad OP(BOP).
//
// As a basis, if we were only given the first term of sequence, it would be most sensible to
// assume constancy; that is, for n >= 2, OP(1, n) = u1.
//
// Hence we obtain the following OPs for the cubic sequence :
//      OP(1, n) = 1                1,_1_, 1, 1, ...
//      OP(2, n) = 7n−6             1, 8,_15_, ...
//      OP(3, n) = 6n^2−11n + 6     1, 8, 27,_58_, ...
//      OP(4, n) = n^3              1, 8, 27, 64, 125, ...
//
// Clearly no BOPs exist for k >= 4.
//
// By considering the sum of FITs generated by the BOPs(indicated in red above),
// we obtain 1 + 15 + 58 = 74.
//
// Consider the following tenth degree polynomial generating function :
//
//      un = 1 − n + n^2 − n^3 + n^4 − n^5 + n^6 − n^7 + n^8 − n^9 + n^10
//
// Find the sum of FITs for the BOPs.


#include <iostream>
#include <vector>

#include "big_fraction.h"


int64_t u_n(int64_t n) {
    int64_t ret{ 1 };

    int64_t term{ 1 };
    for (int8_t i = 1; i < 11; ++i) {
        term *= -n;
        ret += term;
    }

    return ret;
}


using Vector = std::vector<BigFraction>;
using Matrix = std::vector<Vector>;


Vector solve_system(const Matrix& A, const Vector& b) {
    // We are solving for x in Ax = b.
    // We can use Gauss-Jordan elimination to calculate the inverse matrix,
    // and then multiply it by the vector b to get the solution.

    std::cout << "A" << std::endl;
    for (const auto& row : A) {
        for (const auto& el : row)
            std::cout << el << "  ";
        std::cout << std::endl;
    }

    Matrix lhs{ A };
    Matrix rhs;
    for (size_t r = 0; r < A.size(); ++r) {
        rhs.push_back({ });
        for (size_t c = 0; c < A.size(); ++c)
            rhs.back().push_back(0);
        rhs.back()[r] = BigFraction(1);
    }

    Vector order;
    for (size_t r = 0; r < A.size(); ++r) {
        order.push_back(BigFraction(r));
    }

    const size_t numRows = A.size();

    for (size_t curr_row = 0; curr_row < numRows; ++curr_row) {
        // Look for row in [curr_row, numRows) that has largest absolute value to pivot with.
        auto pivot_row{ curr_row };
        BigFraction max_val = lhs[curr_row][curr_row].abs();
        for (size_t other_row = curr_row; other_row < numRows; ++other_row) {
            if (lhs[other_row][curr_row].abs() > max_val) {
                pivot_row = other_row;
                max_val = lhs[other_row][curr_row].abs();
            }
        }
        // If we found a pivot row, then swap with current row in both matrices.
        if (pivot_row != curr_row) {
            std::swap(lhs[curr_row], lhs[pivot_row]);
            std::swap(rhs[curr_row], rhs[pivot_row]);
            std::swap(order[curr_row], order[pivot_row]);
        }

        // If we have a row of all 0's, then we're done.
        if (BigFraction{} == lhs[curr_row][curr_row])
            break;

        // Scale the current row to put a 1 on the diagonal.
        const BigFraction scale = BigFraction{ 1 } / lhs[curr_row][curr_row];
        for (size_t col = 0; col < numRows; ++col) {
            lhs[curr_row][col] *= scale;
            rhs[curr_row][col] *= scale;
        }

        // Subtract a scaled copy of current row from all other rows.
        for (size_t row = 0; row < numRows; ++row) {
            if (row == curr_row)
                continue;
            const BigFraction scale = lhs[row][curr_row];
            for (size_t col = 0; col < numRows; ++col) {
                lhs[row][col] -= scale * lhs[curr_row][col];
                rhs[row][col] -= scale * rhs[curr_row][col];
            }
        }
    }

    std::cout << "lhs" << std::endl;
    for (const auto& row : lhs) {
        for (const auto& el : row)
            std::cout << el << "  ";
        std::cout << std::endl;
    }

    std::cout << "rhs" << std::endl;
    for (const auto& row : rhs) {
        for (const auto& el : row)
            std::cout << el << "  ";
        std::cout << std::endl;
    }

    // We now have an upper triangular matrix, with the last row all 0s.
    // To solve, start with the last element = 1 and work from bottom to top.
    Vector ret{};
    for (size_t row = 0; row < numRows; ++row) {
        BigFraction sum{ };
        for (size_t col = 0; col < numRows; ++col)
            sum += rhs[row][col] * b[col];
        ret.push_back(sum);
    }

    return ret;
}


//int64_t get_lin_fit() {
//    int64_t y_1 = u_n(1);
//    int64_t y_2 = u_n(2);
//    double m = y_2 - y_1;
//    double b = y_1 - m;
//
//    return int64_t(m * 3 + b);
//}

//
//int64_t get_quadratic_fit() {
//    int64_t y_1 = u_n(1);
//    int64_t y_2 = u_n(2);
//    int64_t y_3 = u_n(3);
//
//    // A*n^2 + B*n + C
//
//    // y_1 = A + B + C
//    // y_2 = 4*A + 2*B + C
//    // y_3 = 9*A + 3*B + C
//    // Solve Ax = b
//    //   A = | 1 1 1 |
//    //       | 4 2 1 |
//    //       | 9 3 1 |
//    //   b = <y_1, y_2, y_3>
//
//    return int64_t(m * 3 + b);
//}
//


BigFraction get_fit(int64_t k) {
    Matrix A;
    Vector b;
    const int64_t n{ k + 1 };

    for (int64_t r = 1; r <= n; ++r) {
        A.push_back({ });
        int64_t term{ 1 };
        for (int64_t c = 0; c <= k; ++c, term *= r) {
            A.back().push_back(term);
        }
        b.push_back(u_n(r));
    }

    Vector x = solve_system(A, b);
    std::cout << "x = ";
    for (const auto& el : x)
        std::cout << el << " ";
    std::cout << std::endl;

    //BigFraction ret{ 0 };
    //BigFraction term{ 1 };
    //for (int64_t r = 0; r <= k; ++r) {
    //    ret += x[r] * term;
    //    term *= n + 1;
    //}

    BigFraction ret{ x[k] };
    for (int64_t r = k-1; r >= 0; --r) {
        ret *= n + 1;
        ret += x[r];
    }

    return ret;
}


int main()
{
    std::cout << "Hello World!\n";

    {
        for (int64_t n = 1; n < 12; ++n)
            std::cout << n << "\t" << u_n(n) << std::endl;
    }

    {
        //std::cout << "FIT(1) = " << get_lin_fit() << std::endl;
        std::cout << "FIT(1) = " << get_fit(1) << std::endl;
        std::cout << "FIT(2) = " << get_fit(2) << std::endl;
    }

    {
        BigFraction fit_sum{ 1 };
        for (uint64_t k = 1; k < 10; ++k) {
            auto fit = get_fit(k);
            std::cout << "FIT(" << k << ") = " << fit << std::endl;
            fit_sum += fit;
        }
        std::cout << "sum = " << fit_sum << std::endl;
    }
}
