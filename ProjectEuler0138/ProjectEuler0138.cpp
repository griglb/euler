// Consider the isosceles triangle with base length, b=16, and legs, L=17.
//
// 
//                              ^
//                             /|\
//                            / | \
//                           /  |  \
//                        L /   |   \ L
//                         /  h |    \
//                        /     |     \
//                       /______|______\
//                       |<-----b----->|
// 
// By using the Pythagorean theorem it can be seen that the height of the triangle,
//      h = sqrt(17^2 - 8^2) = 15
// which is one less than the base length.
//
// With b=272 and L=305, we get h=273, which is one more than the base length,
// and this is the second smallest isosceles triangle with the property that
//      h = b +- 1
//
// Find sum(L) for the twelve smallest isosceles triangles for which
// h = b +- 1 and b, L are positive integers.


#include <array>
#include <chrono>
#include <cstdint>
#include <ctime>
#include <iostream>
#include <tuple>
#include <thread>
#include <vector>


// We know that ( b/2, h, L ) is a Pythagorean triplet:
//      L^2 = b^2 / 4 + h^2
// With the relationship between h & b, then there are 2 options:
//      L^2 = b^2 / 4 + (b +- 1)^2
//      L^2 = b^2 / 4 + b^2 +- 2*b + 1
//
// We can use the Pythagorean generator:
//      P(m, n) = { m^2 - n^2, 2mn, m^2 + n^2 }
// We don't need to do any scaling of these triplets, because that
// would be guaranteed to break the h = b +- 1 relationship.

// Looking at the results, it turns out that when 1 triangle is
// generated by (m, n), the next is generated by (m', m) - the
// m becomes the next n.


#ifdef _WIN32
#pragma warning(disable : 4996)
#endif

using namespace std::chrono_literals;

using Triplet = std::tuple<int64_t, int64_t, int64_t>;
using Triangles = std::vector<Triplet>;


struct ThreadParams {
    const size_t num_triangles;
    const int64_t start_m;
    const int64_t end_m;
    const int64_t num_threads;
    Triangles& counts;
};

void thread_func(const ThreadParams& params) {
    std::cout << "\tthread_func, thread id = " << std::this_thread::get_id()
              << ", start_m = " << params.start_m
              << ", end_m = " << params.end_m
              << std::endl;

    for (int64_t m = params.start_m; m < params.end_m; m += params.num_threads) {
        for (int64_t n = 1; n < m; ++n) {
            int64_t a = m * m - n * n;
            int64_t b = 2 * m * n;

            if (b > a)
                break;

            int64_t diff = a < b ? b - 2 * a : a - 2 * b;
            if ((1 == diff) || (-1 == diff)) {
                params.counts.push_back({ a, b, m * m + n * n });
                std::cout << m << "\t" << n << "\t->\t" << a << "\t" << b << "\t" << m * m + n * n << std::endl;
            }

            if (params.num_triangles <= params.counts.size()) {
                std::cout << "\tthread_func, thread id = " << std::this_thread::get_id() << " exiting" << std::endl;
                return;
            }
        }
    }
}


Triangles get_triangles(uint64_t how_many) {
    Triangles ret;

    int64_t n{ 1 };

    while (ret.size() < how_many) {
        for (int64_t m = n + 1; m < 1'000'000'000; ++m) {
            int64_t a = m * m - n * n;
            int64_t b = 2 * m * n;

            int64_t diff = a < b ? b - 2 * a : a - 2 * b;
            if ((1 == diff) || (-1 == diff)) {
                ret.push_back({ a, b, m * m + n * n });
                std::cout << m << "\t" << n << "\t->\t" << a << "\t" << b << "\t" << m * m + n * n << std::endl;
                n = m;
                break;
            }
        }
    }

    return ret;
}

int main()
{
    std::cout << "Hello World!\n";

    //{
    //    auto tris = get_triangles(2);  //  this function evolved into thread_func()
    //    for (const auto& [a, b, c] : tris)
    //        std::cout << a << "\t" << b << "\t" << c << std::endl;
    //}

    //{
    //    Triangles tris;
    //    tris.reserve(15);
    //
    //    // Start with a single thread finding most of the small triangles in a couple seconds.
    //    ThreadParams params{ .num_triangles = 12,
    //                         .start_m = 2,
    //                         .end_m = 250'000,
    //                         .num_threads = 1,
    //                         .counts = tris
    //    };
    //    thread_func(params);
    //
    //    // Then spin up threads for the bigger search
    //    constexpr int64_t kNumThreads{ 10 };
    //
    //    std::array<std::thread, kNumThreads> threads;
    //
    //    for (int64_t ind = 0; ind < kNumThreads; ++ind) {
    //        ThreadParams params{ .num_triangles = 12,
    //                             .start_m = 250'000 + ind,
    //                             .end_m = 1'000'000'000,
    //                             .num_threads = kNumThreads,
    //                             .counts = tris
    //        };
    //        threads[ind] = std::thread(thread_func, params);
    //        std::this_thread::sleep_for(5ms);
    //    }
    //
    //    std::this_thread::sleep_for(500ms);
    //
    //    for (auto& th : threads)
    //        th.join();
    //
    //    uint64_t sum{ 0 };
    //    for (const auto& [a, b, c] : tris) {
    //        std::cout << a << "\t" << b << "\t" << c << std::endl;
    //        sum += c;
    //    }
    //    std::cout << "Sum of " << tris.size() << " triangle edges = " << sum << std::endl;
    //    auto timenow = std::chrono::system_clock::to_time_t(std::chrono::system_clock::now());
    //    std::cout << ctime(&timenow);
    //}

    {
        auto tris = get_triangles(12);
        uint64_t sum{ 0 };
        for (const auto& [a, b, c] : tris) {
            std::cout << a << "\t" << b << "\t" << c << std::endl;
            sum += c;
        }
        std::cout << "Sum of " << tris.size() << " triangle edges = " << sum << std::endl;
    }
}


//4         1       ->      15                  8                   17
//17        4       ->      273                 136                 305
//72        17      ->      4895                2448                5473
//305       72      ->      87841               43920               98209
//1292      305     ->      1576239             788120              1762289
//5473      1292    ->      28284465            14142232            31622993
//23184     5473    ->      507544127           253772064           567451585
//98209     23184   ->      9107509825          4553754912          10182505537
//416020    98209   ->      163427632719        81713816360         182717648081
//1762289   416020  ->      2932589879121       1466294939560       3278735159921
//7465176   1762289 ->      52623190191455      26311595095728      58834515230497
//31622993  7465176 ->      944284833567073     472142416783536     1055742538989025
