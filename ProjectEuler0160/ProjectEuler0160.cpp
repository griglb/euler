// For any N, let f(N) be the last five digits before the trailing zeroes in N!.
// For example,
//      9! = 362880                 so f(9) = 36288
//     10! = 3628800                so f(10) = 36288
//     20! = 2432902008176640000    so f(20) = 17664
//
// Find f(1'000'000'000'000).


#include <iostream>

#include "big_int.h"


// The number of trailing 0s is the min of the number of 2s and 5s in the
// product.  For factorial, there will be way more 2s than 5s, so the number
// of 0s is the number of 5s in the product.
// This isn't just N/5, because there are other powers of 5 to take into account.
// For 25!, for example, you have 25 in the product, which adds 2 5s.

// Last 5 of:
//      10! = 36288
//      20! = 17664
//      30! = 30848
//      40! = 94272
//      50! = 60512
//      60! = 64096
//      70! = 31968
//      80! = 81408
//      90! = 78112
//     100! = 16864
//     200! = 37472
//     300! = 70496
//     400! = 91008
//     500! = 12864
//     600! = 78496
//     700! = 64384
//     800! = 50496
//     900! = 62432
//    1000! = 53472
//
// The last digit of 10! is 8, 8^ = 64, which matches the last digit of 20!.
// In an ideal world, the last digit of 30! is the product of the last digits
// of 10! and 20! -> 8 * 4 = 32.  But the last digit of 30! = 8?!?
// This is because 25 is in the range (20, 30], which adds an extra factor of
// 5 to the product.
//

//      10! =          1 *   1 *   3 *   4 *   1 *   6 *   7 *   8 *   9 *  1 * 100    = XX80...
//      20! =  10! *  11 *   6 *  13 *  14 *   3 *  16 *  17 *  18 *  19 *  2 * 100    = YY80... *  XX800 = ZZ40...
//      30! =  20! *  21 *  11 *  23 *  12 *   1 *  26 *  27 *  28 *  29 *  3 * 1000   = YY40... * XX2000 = ZZ80...
//      40! =  30! *  31 *  16 *  33 *  34 *   7 *  36 *  37 *  38 *  39 *  4 * 100    = YY80... *  XX400 = ZZ20...
//      50! =  40! *  41 *  21 *  43 *  22 *   9 *  46 *  47 *  48 *  49 *  5 * 1000   = YY20... * XX6000 = ZZ20...
//      60! =  50! *  51 *  26 *  53 *  54 *  11 *  56 *  57 *  58 *  59 *  6 * 100    = YY20... *  XX800 = ZZ60...
//      70! =  60! *  61 *  31 *  63 *  64 *  13 *  66 *  67 *  68 *  69 *  7 * 100    = YY60... *  XX800 = ZZ80...
//      80! =  70! *  71 *  36 *  73 *  37 *   3 *  76 *  77 *  78 *  79 *  8 * 1000   = YY80... * XX6000 = ZZ80...
//      90! =  80! *  81 *  41 *  83 *  84 *  17 *  86 *  87 *  88 *  89 *  9 * 100    = YY80... *  XX400 = ZZ20...
//     100! =  90! *  91 *  46 *  93 *  94 *  19 *  96 *  97 *  98 *  99 * 10 * 100    = YY20... * XX2000 = ZZ40...

//     110! = 100! * 101 *  51 * 103 * 104 *  21 * 106 * 107 * 108 * 109 * 11 * 100    = YY20... * XX2000 = ZZ40...
//     120! = 110! * 111 *  56 * 113 * 114 *  23 * 116 * 117 * 118 * 119 * 12 * 100    = YY20... * XX2000 = ZZ40...
//     130! = 120! * 121 *  61 * 123 *  31 *   1 * 126 * 127 * 128 * 129 * 13 * 100    = YY20... * XX2000 = ZZ40...
//     140! = 130! * 131 *  66 * 133 * 134 *  27 * 136 * 137 * 138 * 139 * 14 * 100    = YY20... * XX2000 = ZZ40...
//     150! = 140! * 141 *  71 * 143 * 144 *  29 * 146 * 147 * 148 * 149 * 15 * 100    = YY20... * XX2000 = ZZ40...
//     160! = 150! * 151 *  76 * 153 * 154 *  31 * 156 * 157 * 158 * 159 * 16 * 100    = YY20... * XX2000 = ZZ40...
//     170! = 160! * 161 *  81 * 163 * 164 *  33 * 166 * 167 * 168 * 169 * 17 * 100    = YY20... * XX2000 = ZZ40...
//     180! = 170! * 171 *  86 * 173 *  87 *   7 * 176 * 177 * 178 * 179 * 18 * 100    = YY20... * XX2000 = ZZ40...
//     190! = 180! * 181 *  91 * 183 * 184 *  37 * 186 * 187 * 188 * 189 * 19 * 100    = YY20... * XX2000 = ZZ40...
//     200! = 190! * 191 *  96 * 193 * 194 *  39 * 196 * 197 * 198 * 199 *  2 * 1000   = YY20... * XX2000 = ZZ40...

// The output using int64_t for up to 1E7:
//  100000         62496
//  200000         12544
//  300000         20096
//  400000         94688
//  500000         62496
//  600000         20736
//  700000         70112
//  800000         54176
//  900000         84736
// 1000000         12544
// 1100000         81184
// 1200000         92576
// 1300000         53984
// 1400000         98656
// 1500000         20096
// 1600000         38144
// 1700000         59552
// 1800000         88096
// 1900000         42752
// 2000000         94688
// 2100000         21952
// 2200000         83776
// 2300000         16672
// 2400000         69824
// 2500000         62496
// 2600000         82208
// 2700000         13824
// 2800000         50272
// 2900000         68256
// 3000000         20736
// 3100000         91392
// 3200000         46112
// 3300000         94688
// 3400000         81504
// 3500000         70112
// 3600000         33632
// 3700000         75744
// 3800000         74688
// 3900000         29984
// 4000000         54176
// 4100000         51584
// 4200000         59616
// 4300000         77856
// 4400000         23648
// 4500000         84736
// 4600000         37632
// 4700000         28544
// 4800000         12992
// 4900000         59776
// 5000000         12544
// 5100000         88576
// 5200000         51232
// 5300000         02272
// 5400000         79136
// 5500000         81184
// 5600000         97312
// 5700000         62816
// 5800000         24384
// 5900000         56768
// 6000000         92576
// 6100000         30688
// 6200000         85792
// 6300000         25664
// 6400000         67808
// 6500000         53984
// 6600000         09312
// 6700000         71936
// 6800000         48096
// 6900000         29504
// 7000000         98656
// 7100000         50496
// 7200000         43776
// 7300000         54944
// 7400000         49664
// 7500000         20096
// 7600000         90112
// 7700000         46912
// 7800000         09984
// 7900000         61376
// 8000000         38144
// 8100000         77376
// 8200000         50016
// 8300000         74656
// 8400000         47872
// 8500000         59552
// 8600000         63904
// 8700000         95264
// 8800000         31232
// 8900000         51872
// 9000000         88096
// 9100000         07232
// 9200000         68832
// 9300000         40992
// 9400000         29312
// 9500000         42752
// 9600000         60896
// 9700000         50016
// 9800000         65856
// 9900000         21024
//10000000         94688

// Here we can notice an interesting pattern - numbers that differ by a factor
// of 5 have the same value for f(N):
//  f(100000) =  f(500000) =  f(2500000) = 62496
//  f(200000) = f(1000000) =  f(5000000) = 12544
//  f(300000) = f(1500000) =  f(7500000) = 20096
//  f(400000) = f(2000000) = f(10000000) = 94688
//  f(600000) = f(3000000) = 20736
//  f(700000) = f(3500000) = 70112
//  f(800000) = f(4000000) = 54176
//  f(900000) = f(4500000) = 84736
// f(1100000) = f(5500000) = 81184
// f(1200000) = f(6000000) = 92576
// f(1300000) = f(6500000) = 53984
// f(1400000) = f(7000000) = 98656
// f(1600000) = f(8000000) = 38144
// f(1700000) = f(8500000) = 59552
// f(1800000) = f(9000000) = 88096
// f(1900000) = f(9500000) = 42752
//
// By this pattern:
//  f(1'000'000'000'000) = f(200'000'000'000)
//                       = f(40'000'000'000)
//                       = f(8'000'000'000)
//                       = f(1'600'000'000)
//                       = f(320'000'000)
//                       = f(64'000'000)
//                       = f(12'800'000)
//                       = f(2'560'000)
//                       = 17576
// We can't go to smaller values of N in f(N) because we need to make sure we
// cover all 5 digit subsets.  But this is much faster than 1E12.


void playground() {
    int64_t fact{ 1 };
    //BigInt bfact{ 1 };

    for (int64_t n = 2; n <= 10'000'000; ++n) {
        fact *= n;
        while (0 == fact % 10)
            fact /= 10;
        fact %= 100'000'000'000;

        //bfact *= n;

        if (n % 100'000 == 0) {
//            std::cout << n << "\t" << fact << std::endl;
            //const auto digits = bfact.get_digits();
            //auto dig = digits.crbegin();
            //for ( ; *dig == 0; ++dig);

            std::cout << n << "\t";

            //std::vector<uint16_t> last_5;
            //last_5.resize(5);

            //for (int16_t i = 4; i >= 0; --i)
            //    last_5[i] = *dig++;

            //for (auto &d : last_5)
            //    std::cout << d;

            std::cout << "\t" << fact % 100'000;

            std::cout << std::endl;
        }
    }

//    std::cout << fact;
}


void solve() {
    int64_t fact{ 1 };

    for (int64_t n = 2; n <= 2'560'000; ++n) {
        fact *= n;
        while (0 == fact % 10)
            fact /= 10;
        fact %= 100'000'000'000;
    }

    std::cout << fact % 100'000;

    std::cout << std::endl;
}

int main()
{
    std::cout << "Hello World!\n";

    //{
    //    playground();
    //}

    {
        solve();
    }
}
